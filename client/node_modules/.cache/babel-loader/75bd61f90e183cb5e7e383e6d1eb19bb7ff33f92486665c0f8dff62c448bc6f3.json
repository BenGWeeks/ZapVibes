{"ast":null,"code":"var _a;\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { css, divProperties, elementContains, focusFirstChild, getNativeProps, on, shallowCompare, getPropsWithDefaults } from '../../Utilities';\nimport { calculateGapSpace, getRectangleFromTarget } from '../../utilities/positioning/positioning';\nimport { positionCallout, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget, useOnEvent } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\nvar COMPONENT_NAME = 'CalloutContentBase';\nvar ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);\nvar BEAK_ORIGIN_POSITION = {\n  top: 0,\n  left: 0\n};\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nvar OFF_SCREEN_STYLE = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none'\n};\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nvar ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\nvar DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\nvar getClassNames = classNamesFunction({\n  disableCaching: true // disabling caching because stylesProp.position mutates often\n});\n/**\n * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.\n */\nfunction useBounds(_a, targetRef, targetWindow) {\n  var bounds = _a.bounds,\n    _b = _a.minPagePadding,\n    minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b,\n    target = _a.target;\n  var _c = React.useState(false),\n    targetWindowResized = _c[0],\n    setTargetWindowResized = _c[1];\n  var cachedBounds = React.useRef();\n  var getBounds = React.useCallback(function () {\n    if (!cachedBounds.current || targetWindowResized) {\n      var currentBounds = typeof bounds === 'function' ? targetWindow ? bounds(target, targetWindow) : undefined : bounds;\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right - minPagePadding,\n          bottom: currentBounds.bottom - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2\n        };\n      }\n      cachedBounds.current = currentBounds;\n      targetWindowResized && setTargetWindowResized(false);\n    }\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);\n  var async = useAsync();\n  useOnEvent(targetWindow, 'resize', async.debounce(function () {\n    setTargetWindowResized(true);\n  }, 500, {\n    leading: true\n  }));\n  return getBounds;\n}\n/**\n * (Hook) to return the maximum available height for the Callout to render into.\n */\nfunction useMaxHeight(_a, getBounds, targetRef, positions) {\n  var _b;\n  var calloutMaxHeight = _a.calloutMaxHeight,\n    finalHeight = _a.finalHeight,\n    directionalHint = _a.directionalHint,\n    directionalHintFixed = _a.directionalHintFixed,\n    hidden = _a.hidden,\n    gapSpace = _a.gapSpace,\n    beakWidth = _a.beakWidth,\n    isBeakVisible = _a.isBeakVisible;\n  var _c = React.useState(),\n    maxHeight = _c[0],\n    setMaxHeight = _c[1];\n  var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {},\n    top = _d.top,\n    bottom = _d.bottom;\n  var targetRect = (targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) ? getRectangleFromTarget(targetRef.current) : undefined;\n  React.useEffect(function () {\n    var _a;\n    var bounds = (_a = getBounds()) !== null && _a !== void 0 ? _a : {};\n    var topBounds = bounds.top;\n    var bottomBounds = bounds.bottom;\n    var calculatedHeight;\n    // If aligned to top edge of target, update bottom bounds to the top of the target\n    // (accounting for gap space and beak)\n    if ((positions === null || positions === void 0 ? void 0 : positions.targetEdge) === RectangleEdge.top && (targetRect === null || targetRect === void 0 ? void 0 : targetRect.top)) {\n      bottomBounds = targetRect.top - calculateGapSpace(isBeakVisible, beakWidth, gapSpace);\n    }\n    if (typeof top === 'number' && bottomBounds) {\n      calculatedHeight = bottomBounds - top;\n    } else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {\n      calculatedHeight = bottomBounds - topBounds - bottom;\n    }\n    if (!calloutMaxHeight && !hidden || calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight) {\n      setMaxHeight(calculatedHeight);\n    } else if (calloutMaxHeight) {\n      setMaxHeight(calloutMaxHeight);\n    } else {\n      setMaxHeight(undefined);\n    }\n  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top, gapSpace, beakWidth, isBeakVisible, targetRect]);\n  return maxHeight;\n}\n/**\n * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.\n */\nfunction usePositions(props, hostElement, calloutElement, targetRef, getBounds, popupRef) {\n  var _a = React.useState(),\n    positions = _a[0],\n    setPositions = _a[1];\n  var positionAttempts = React.useRef(0);\n  var previousTarget = React.useRef();\n  var async = useAsync();\n  var hidden = props.hidden,\n    target = props.target,\n    finalHeight = props.finalHeight,\n    calloutMaxHeight = props.calloutMaxHeight,\n    onPositioned = props.onPositioned,\n    directionalHint = props.directionalHint,\n    hideOverflow = props.hideOverflow,\n    preferScrollResizePositioning = props.preferScrollResizePositioning;\n  var win = useWindow();\n  var localRef = React.useRef();\n  var popupStyles;\n  if (localRef.current !== popupRef.current) {\n    localRef.current = popupRef.current;\n    popupStyles = popupRef.current ? win === null || win === void 0 ? void 0 : win.getComputedStyle(popupRef.current) : undefined;\n  }\n  var popupOverflowY = popupStyles === null || popupStyles === void 0 ? void 0 : popupStyles.overflowY;\n  React.useEffect(function () {\n    if (!hidden) {\n      var timerId_1 = async.requestAnimationFrame(function () {\n        var _a, _b;\n        if (hostElement.current && calloutElement) {\n          var currentProps = __assign(__assign({}, props), {\n            target: targetRef.current,\n            bounds: getBounds()\n          });\n          // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc\n          var dupeCalloutElement = calloutElement.cloneNode(true);\n          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? \"\".concat(calloutMaxHeight) : '';\n          dupeCalloutElement.style.visibility = 'hidden';\n          (_a = calloutElement.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(dupeCalloutElement);\n          var previousPositions = previousTarget.current === target ? positions : undefined;\n          // only account for scroll resizing if styles allow callout to scroll\n          // (popup styles determine if callout will scroll)\n          var isOverflowYHidden = hideOverflow || popupOverflowY === 'clip' || popupOverflowY === 'hidden';\n          var shouldScroll = preferScrollResizePositioning && !isOverflowYHidden;\n          // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions, shouldScroll);\n          // clean up duplicate calloutElement\n          (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement);\n          // Set the new position only when the positions do not exist or one of the new callout positions\n          // is different. The position should not change if the position is within 2 decimal places.\n          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);\n          }\n        }\n      }, calloutElement);\n      previousTarget.current = target;\n      return function () {\n        async.cancelAnimationFrame(timerId_1);\n        previousTarget.current = undefined;\n      };\n    } else {\n      // When the callout is hidden, clear position state so that it is not accidentally used next render.\n      setPositions(undefined);\n      positionAttempts.current = 0;\n    }\n  }, [hidden, directionalHint, async, calloutElement, calloutMaxHeight, hostElement, targetRef, finalHeight, getBounds, onPositioned, positions, props, target, hideOverflow, preferScrollResizePositioning, popupOverflowY]);\n  return positions;\n}\n/**\n * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\nfunction useAutoFocus(_a, positions, calloutElement) {\n  var hidden = _a.hidden,\n    setInitialFocus = _a.setInitialFocus;\n  var async = useAsync();\n  var hasPositions = !!positions;\n  React.useEffect(function () {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement) {\n      var timerId_2 = async.requestAnimationFrame(function () {\n        return focusFirstChild(calloutElement);\n      }, calloutElement);\n      return function () {\n        return async.cancelAnimationFrame(timerId_2);\n      };\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n/**\n * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\nfunction useDismissHandlers(_a, positions, hostElement, targetRef, targetWindow) {\n  var hidden = _a.hidden,\n    onDismiss = _a.onDismiss,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnScroll = _a.preventDismissOnScroll,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnResize = _a.preventDismissOnResize,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnLostFocus = _a.preventDismissOnLostFocus,\n    dismissOnTargetClick = _a.dismissOnTargetClick,\n    shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus,\n    preventDismissOnEvent = _a.preventDismissOnEvent;\n  var isMouseDownOnPopup = React.useRef(false);\n  var async = useAsync();\n  var mouseDownHandlers = useConst([function () {\n    isMouseDownOnPopup.current = true;\n  }, function () {\n    isMouseDownOnPopup.current = false;\n  }]);\n  var positionsExists = !!positions;\n  React.useEffect(function () {\n    var dismissOnScroll = function (ev) {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n    var dismissOnResize = function (ev) {\n      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n    var dismissOnLostFocus = function (ev) {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n    var dismissOnClickOrScroll = function (ev) {\n      var eventPaths = ev.composedPath ? ev.composedPath() : [];\n      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;\n      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);\n      // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || 'stopPropagation' in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {\n          return;\n        }\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n    var dismissOnTargetWindowBlur = function (ev) {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    var disposablesPromise = new Promise(function (resolve) {\n      async.setTimeout(function () {\n        if (!hidden && targetWindow) {\n          var disposables_1 = [on(targetWindow, 'scroll', dismissOnScroll, true), on(targetWindow, 'resize', dismissOnResize, true), on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true), on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true), on(targetWindow, 'blur', dismissOnTargetWindowBlur, true)];\n          resolve(function () {\n            disposables_1.forEach(function (dispose) {\n              return dispose();\n            });\n          });\n        }\n      }, 0);\n    });\n    return function () {\n      disposablesPromise.then(function (dispose) {\n        return dispose();\n      });\n    };\n  }, [hidden, async, hostElement, targetRef, targetWindow, onDismiss, shouldDismissOnWindowFocus, dismissOnTargetClick, preventDismissOnLostFocus, preventDismissOnResize, preventDismissOnScroll, positionsExists, preventDismissOnEvent]);\n  return mouseDownHandlers;\n}\nexport var CalloutContentBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var styles = props.styles,\n    style = props.style,\n    ariaLabel = props.ariaLabel,\n    ariaDescribedBy = props.ariaDescribedBy,\n    ariaLabelledBy = props.ariaLabelledBy,\n    className = props.className,\n    isBeakVisible = props.isBeakVisible,\n    children = props.children,\n    beakWidth = props.beakWidth,\n    calloutWidth = props.calloutWidth,\n    calloutMaxWidth = props.calloutMaxWidth,\n    calloutMinWidth = props.calloutMinWidth,\n    doNotLayer = props.doNotLayer,\n    finalHeight = props.finalHeight,\n    _a = props.hideOverflow,\n    hideOverflow = _a === void 0 ? !!finalHeight : _a,\n    backgroundColor = props.backgroundColor,\n    calloutMaxHeight = props.calloutMaxHeight,\n    onScroll = props.onScroll,\n    // eslint-disable-next-line deprecation/deprecation\n    _b = props.shouldRestoreFocus,\n    // eslint-disable-next-line deprecation/deprecation\n    shouldRestoreFocus = _b === void 0 ? true : _b,\n    target = props.target,\n    hidden = props.hidden,\n    onLayerMounted = props.onLayerMounted,\n    popupProps = props.popupProps;\n  var hostElement = React.useRef(null);\n  var popupRef = React.useRef(null);\n  var mergedPopupRefs = useMergedRefs(popupRef, popupProps === null || popupProps === void 0 ? void 0 : popupProps.ref);\n  var _c = React.useState(null),\n    calloutElement = _c[0],\n    setCalloutElement = _c[1];\n  var calloutCallback = React.useCallback(function (calloutEl) {\n    setCalloutElement(calloutEl);\n  }, []);\n  var rootRef = useMergedRefs(hostElement, forwardedRef);\n  var _d = useTarget(props.target, {\n      current: calloutElement\n    }),\n    targetRef = _d[0],\n    targetWindow = _d[1];\n  var getBounds = useBounds(props, targetRef, targetWindow);\n  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds, mergedPopupRefs);\n  var maxHeight = useMaxHeight(props, getBounds, targetRef, positions);\n  var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow),\n    mouseDownOnPopup = _e[0],\n    mouseUpOnPopup = _e[1];\n  // do not set both top and bottom css props from positions\n  // instead, use maxHeight\n  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);\n  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), {\n    maxHeight: maxHeight\n  });\n  if (isForcedInBounds) {\n    cssPositions.bottom = undefined;\n  }\n  useAutoFocus(props, positions, calloutElement);\n  React.useEffect(function () {\n    if (!hidden) {\n      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n  }, [hidden]);\n  // If there is no target window then we are likely in server side rendering and we should not render anything.\n  if (!targetWindow) {\n    return null;\n  }\n  var overflowYHidden = hideOverflow;\n  var beakVisible = isBeakVisible && !!target;\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    overflowYHidden: overflowYHidden,\n    calloutWidth: calloutWidth,\n    positions: positions,\n    beakWidth: beakWidth,\n    backgroundColor: backgroundColor,\n    calloutMaxWidth: calloutMaxWidth,\n    calloutMinWidth: calloutMinWidth,\n    doNotLayer: doNotLayer\n  });\n  var overflowStyle = __assign(__assign({\n    maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%'\n  }, style), overflowYHidden && {\n    overflowY: 'hidden'\n  });\n  var visibilityStyle = props.hidden ? {\n    visibility: 'hidden'\n  } : undefined;\n  // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n  return React.createElement(\"div\", {\n    ref: rootRef,\n    className: classNames.container,\n    style: visibilityStyle\n  }, React.createElement(\"div\", __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {\n    className: css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),\n    style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: calloutCallback\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beak,\n    style: getBeakPosition(positions)\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beakCurtain\n  }), React.createElement(Popup\n  // don't use getNativeElementProps for role and roledescription because it will also\n  // pass through data-* props (resulting in them being used in two places)\n  , __assign({\n    // don't use getNativeElementProps for role and roledescription because it will also\n    // pass through data-* props (resulting in them being used in two places)\n    role: props.role,\n    \"aria-roledescription\": props['aria-roledescription'],\n    ariaDescribedBy: ariaDescribedBy,\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    className: classNames.calloutMain,\n    onDismiss: props.onDismiss,\n    onMouseDown: mouseDownOnPopup,\n    onMouseUp: mouseUpOnPopup,\n    onRestoreFocus: props.onRestoreFocus,\n    onScroll: onScroll,\n    shouldRestoreFocus: shouldRestoreFocus,\n    style: overflowStyle\n  }, popupProps, {\n    ref: mergedPopupRefs\n  }), children)));\n}), function (previousProps, nextProps) {\n  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n  return shallowCompare(previousProps, nextProps);\n});\n/**\n * (Utility) to find and return the current `Callout` Beak position.\n *\n * @param positions\n */\nfunction getBeakPosition(positions) {\n  var _a, _b;\n  var beakPositionStyle = __assign(__assign({}, (_a = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a === void 0 ? void 0 : _a.elementPosition), {\n    display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? 'none' : undefined\n  });\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n  return beakPositionStyle;\n}\n/**\n * (Utility) used to compare two different elementPositions to determine whether they are equal.\n *\n * @param prevElementPositions\n * @param newElementPosition\n */\nfunction arePositionsEqual(prevElementPositions, newElementPosition) {\n  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);\n}\n/**\n * (Utility) used in **arePositionsEqual** to compare two different elementPositions.\n *\n * @param prevElementPositions\n * @param newElementPositions\n */\nfunction comparePositions(prevElementPositions, newElementPositions) {\n  for (var key in newElementPositions) {\n    if (newElementPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = prevElementPositions[key];\n      var newPositionEdge = newElementPositions[key];\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nCalloutContentBase.displayName = COMPONENT_NAME;","map":{"version":3,"names":["React","DirectionalHint","css","divProperties","elementContains","focusFirstChild","getNativeProps","on","shallowCompare","getPropsWithDefaults","calculateGapSpace","getRectangleFromTarget","positionCallout","RectangleEdge","positionCard","getBoundsFromTargetWindow","Popup","classNamesFunction","AnimationClassNames","useMergedRefs","useAsync","useConst","useTarget","useOnEvent","useWindow","COMPONENT_NAME","ANIMATIONS","_a","top","slideUpIn10","bottom","slideDownIn10","left","slideLeftIn10","right","slideRightIn10","BEAK_ORIGIN_POSITION","OFF_SCREEN_STYLE","opacity","filter","pointerEvents","ARIA_ROLE_ATTRIBUTES","DEFAULT_PROPS","preventDismissOnLostFocus","preventDismissOnScroll","preventDismissOnResize","isBeakVisible","beakWidth","gapSpace","minPagePadding","directionalHint","bottomAutoEdge","getClassNames","disableCaching","useBounds","targetRef","targetWindow","bounds","_b","target","_c","useState","targetWindowResized","setTargetWindowResized","cachedBounds","useRef","getBounds","useCallback","current","currentBounds","undefined","width","height","async","debounce","leading","useMaxHeight","positions","calloutMaxHeight","finalHeight","directionalHintFixed","hidden","maxHeight","setMaxHeight","_d","elementPosition","targetRect","useEffect","topBounds","bottomBounds","calculatedHeight","targetEdge","usePositions","props","hostElement","calloutElement","popupRef","setPositions","positionAttempts","previousTarget","onPositioned","hideOverflow","preferScrollResizePositioning","win","localRef","popupStyles","getComputedStyle","popupOverflowY","overflowY","timerId_1","requestAnimationFrame","currentProps","__assign","dupeCalloutElement","cloneNode","style","concat","visibility","parentElement","appendChild","previousPositions","isOverflowYHidden","shouldScroll","newPositions","removeChild","arePositionsEqual","cancelAnimationFrame","useAutoFocus","setInitialFocus","hasPositions","timerId_2","useDismissHandlers","onDismiss","dismissOnTargetClick","shouldDismissOnWindowFocus","preventDismissOnEvent","isMouseDownOnPopup","mouseDownHandlers","positionsExists","dismissOnScroll","ev","dismissOnClickOrScroll","dismissOnResize","dismissOnLostFocus","eventPaths","composedPath","length","isEventTargetOutsideCallout","dismissOnTargetWindowBlur","document","hasFocus","relatedTarget","disposablesPromise","Promise","resolve","setTimeout","disposables_1","documentElement","forEach","dispose","then","CalloutContentBase","memo","forwardRef","propsWithoutDefaults","forwardedRef","styles","ariaLabel","ariaDescribedBy","ariaLabelledBy","className","children","calloutWidth","calloutMaxWidth","calloutMinWidth","doNotLayer","backgroundColor","onScroll","shouldRestoreFocus","onLayerMounted","popupProps","mergedPopupRefs","ref","setCalloutElement","calloutCallback","calloutEl","rootRef","_e","mouseDownOnPopup","mouseUpOnPopup","isForcedInBounds","cssPositions","overflowYHidden","beakVisible","classNames","theme","overflowStyle","visibilityStyle","createElement","container","root","tabIndex","beak","getBeakPosition","beakCurtain","role","calloutMain","onMouseDown","onMouseUp","onRestoreFocus","previousProps","nextProps","shouldUpdateWhenHidden","beakPositionStyle","beakPosition","display","hideBeak","prevElementPositions","newElementPosition","comparePositions","newElementPositions","key","hasOwnProperty","oldPositionEdge","newPositionEdge","toFixed","displayName"],"sources":["/workspaces/ZapVibes/node_modules/@fluentui/react/lib/components/src/components/Callout/CalloutContent.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  css,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getNativeProps,\n  on,\n  shallowCompare,\n  getPropsWithDefaults,\n  Async,\n} from '../../Utilities';\nimport { calculateGapSpace, getRectangleFromTarget } from '../../utilities/positioning/positioning';\nimport { positionCallout, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget, useOnEvent } from '@fluentui/react-hooks';\nimport type { ICalloutProps, ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\nimport type { Point, IRectangle } from '../../Utilities';\nimport type { ICalloutPositionedInfo, IPositionProps, IPosition } from '../../Positioning';\nimport type { Target } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\n\nconst COMPONENT_NAME = 'CalloutContentBase';\n\nconst ANIMATIONS: { [key: number]: string | undefined } = {\n  [RectangleEdge.top]: AnimationClassNames.slideUpIn10,\n  [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,\n  [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,\n  [RectangleEdge.right]: AnimationClassNames.slideRightIn10,\n};\n\nconst BEAK_ORIGIN_POSITION = { top: 0, left: 0 };\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nconst OFF_SCREEN_STYLE: React.CSSProperties = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none',\n};\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nconst ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nconst DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n} as const;\n\nconst getClassNames = classNamesFunction<ICalloutContentStyleProps, ICalloutContentStyles>({\n  disableCaching: true, // disabling caching because stylesProp.position mutates often\n});\n\n/**\n * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.\n */\nfunction useBounds(\n  { bounds, minPagePadding = DEFAULT_PROPS.minPagePadding, target }: ICalloutProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const [targetWindowResized, setTargetWindowResized] = React.useState(false);\n  const cachedBounds = React.useRef<IRectangle | undefined>();\n\n  const getBounds = React.useCallback((): IRectangle | undefined => {\n    if (!cachedBounds.current || targetWindowResized) {\n      let currentBounds =\n        typeof bounds === 'function' ? (targetWindow ? bounds(target, targetWindow) : undefined) : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right! - minPagePadding,\n          bottom: currentBounds.bottom! - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2,\n        };\n      }\n      cachedBounds.current = currentBounds;\n      targetWindowResized && setTargetWindowResized(false);\n    }\n\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);\n\n  const async: Async = useAsync();\n  useOnEvent(\n    targetWindow,\n    'resize',\n    async.debounce(\n      () => {\n        setTargetWindowResized(true);\n      },\n      500,\n      { leading: true },\n    ),\n  );\n\n  return getBounds;\n}\n\n/**\n * (Hook) to return the maximum available height for the Callout to render into.\n */\nfunction useMaxHeight(\n  {\n    calloutMaxHeight,\n    finalHeight,\n    directionalHint,\n    directionalHintFixed,\n    hidden,\n    gapSpace,\n    beakWidth,\n    isBeakVisible,\n  }: ICalloutProps,\n  getBounds: () => IRectangle | undefined,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  positions?: ICalloutPositionedInfo,\n) {\n  const [maxHeight, setMaxHeight] = React.useState<number | undefined>();\n  const { top, bottom } = positions?.elementPosition ?? {};\n  const targetRect = targetRef?.current ? getRectangleFromTarget(targetRef.current) : undefined;\n\n  React.useEffect(() => {\n    const bounds = getBounds() ?? ({} as IRectangle);\n    const { top: topBounds } = bounds;\n    let { bottom: bottomBounds } = bounds;\n    let calculatedHeight: number | undefined;\n\n    // If aligned to top edge of target, update bottom bounds to the top of the target\n    // (accounting for gap space and beak)\n    if (positions?.targetEdge === RectangleEdge.top && targetRect?.top) {\n      bottomBounds = targetRect.top - calculateGapSpace(isBeakVisible, beakWidth, gapSpace);\n    }\n\n    if (typeof top === 'number' && bottomBounds) {\n      calculatedHeight = bottomBounds - top;\n    } else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {\n      calculatedHeight = bottomBounds - topBounds - bottom;\n    }\n\n    if (\n      (!calloutMaxHeight && !hidden) ||\n      (calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight)\n    ) {\n      setMaxHeight(calculatedHeight);\n    } else if (calloutMaxHeight) {\n      setMaxHeight(calloutMaxHeight);\n    } else {\n      setMaxHeight(undefined);\n    }\n  }, [\n    bottom,\n    calloutMaxHeight,\n    finalHeight,\n    directionalHint,\n    directionalHintFixed,\n    getBounds,\n    hidden,\n    positions,\n    top,\n    gapSpace,\n    beakWidth,\n    isBeakVisible,\n    targetRect,\n  ]);\n\n  return maxHeight;\n}\n\n/**\n * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.\n */\nfunction usePositions(\n  props: ICalloutProps,\n  hostElement: React.RefObject<HTMLDivElement>,\n  calloutElement: HTMLDivElement | null,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getBounds: () => IRectangle | undefined,\n  popupRef: React.RefObject<HTMLDivElement>,\n) {\n  const [positions, setPositions] = React.useState<ICalloutPositionedInfo>();\n  const positionAttempts = React.useRef(0);\n  const previousTarget = React.useRef<Target>();\n  const async = useAsync();\n  const {\n    hidden,\n    target,\n    finalHeight,\n    calloutMaxHeight,\n    onPositioned,\n    directionalHint,\n    hideOverflow,\n    preferScrollResizePositioning,\n  } = props;\n\n  const win = useWindow();\n  const localRef = React.useRef<HTMLDivElement | null>();\n  let popupStyles: CSSStyleDeclaration | undefined;\n  if (localRef.current !== popupRef.current) {\n    localRef.current = popupRef.current;\n    popupStyles = popupRef.current ? win?.getComputedStyle(popupRef.current) : undefined;\n  }\n  const popupOverflowY = popupStyles?.overflowY;\n\n  React.useEffect(() => {\n    if (!hidden) {\n      const timerId = async.requestAnimationFrame(() => {\n        if (hostElement.current && calloutElement) {\n          const currentProps: IPositionProps = {\n            ...props,\n            target: targetRef.current!,\n            bounds: getBounds(),\n          };\n\n          // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc\n          const dupeCalloutElement = calloutElement.cloneNode(true) as HTMLElement;\n          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? `${calloutMaxHeight}` : '';\n          dupeCalloutElement.style.visibility = 'hidden';\n          calloutElement.parentElement?.appendChild(dupeCalloutElement);\n\n          const previousPositions = previousTarget.current === target ? positions : undefined;\n\n          // only account for scroll resizing if styles allow callout to scroll\n          // (popup styles determine if callout will scroll)\n          const isOverflowYHidden = hideOverflow || popupOverflowY === 'clip' || popupOverflowY === 'hidden';\n          const shouldScroll = preferScrollResizePositioning && !isOverflowYHidden;\n\n          // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n          const newPositions: ICalloutPositionedInfo = finalHeight\n            ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions)\n            : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions, shouldScroll);\n\n          // clean up duplicate calloutElement\n          calloutElement.parentElement?.removeChild(dupeCalloutElement);\n\n          // Set the new position only when the positions do not exist or one of the new callout positions\n          // is different. The position should not change if the position is within 2 decimal places.\n          if (\n            (!positions && newPositions) ||\n            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n          ) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned?.(positions);\n          }\n        }\n      }, calloutElement);\n\n      previousTarget.current = target;\n\n      return () => {\n        async.cancelAnimationFrame(timerId);\n        previousTarget.current = undefined;\n      };\n    } else {\n      // When the callout is hidden, clear position state so that it is not accidentally used next render.\n      setPositions(undefined);\n      positionAttempts.current = 0;\n    }\n  }, [\n    hidden,\n    directionalHint,\n    async,\n    calloutElement,\n    calloutMaxHeight,\n    hostElement,\n    targetRef,\n    finalHeight,\n    getBounds,\n    onPositioned,\n    positions,\n    props,\n    target,\n    hideOverflow,\n    preferScrollResizePositioning,\n    popupOverflowY,\n  ]);\n\n  return positions;\n}\n\n/**\n * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\nfunction useAutoFocus(\n  { hidden, setInitialFocus }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  calloutElement: HTMLDivElement | null,\n) {\n  const async = useAsync();\n  const hasPositions = !!positions;\n  React.useEffect(() => {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement) {\n      const timerId = async.requestAnimationFrame(() => focusFirstChild(calloutElement), calloutElement);\n\n      return () => async.cancelAnimationFrame(timerId);\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n\n/**\n * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\nfunction useDismissHandlers(\n  {\n    hidden,\n    onDismiss,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnScroll,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnResize,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnLostFocus,\n    dismissOnTargetClick,\n    shouldDismissOnWindowFocus,\n    preventDismissOnEvent,\n  }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const isMouseDownOnPopup = React.useRef(false);\n  const async = useAsync();\n\n  const mouseDownHandlers = useConst([\n    () => {\n      isMouseDownOnPopup.current = true;\n    },\n    () => {\n      isMouseDownOnPopup.current = false;\n    },\n  ] as const);\n\n  const positionsExists = !!positions;\n\n  React.useEffect(() => {\n    const dismissOnScroll = (ev: Event) => {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnResize = (ev: Event) => {\n      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnLostFocus = (ev: Event) => {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnClickOrScroll = (ev: Event) => {\n      const eventPaths: Array<EventTarget> = ev.composedPath ? ev.composedPath() : [];\n      const target = eventPaths.length > 0 ? (eventPaths[0] as HTMLElement) : (ev.target as HTMLElement);\n      const isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);\n\n      // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (\n        (!targetRef.current && isEventTargetOutsideCallout) ||\n        (ev.target !== targetWindow &&\n          isEventTargetOutsideCallout &&\n          (!targetRef.current ||\n            'stopPropagation' in targetRef.current ||\n            dismissOnTargetClick ||\n            (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n      ) {\n        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {\n          return;\n        }\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnTargetWindowBlur = (ev: FocusEvent) => {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if (\n        ((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n          (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&\n        !targetWindow?.document.hasFocus() &&\n        ev.relatedTarget === null\n      ) {\n        onDismiss?.(ev);\n      }\n    };\n\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    const disposablesPromise = new Promise<() => void>(resolve => {\n      async.setTimeout(() => {\n        if (!hidden && targetWindow) {\n          const disposables = [\n            on(targetWindow, 'scroll', dismissOnScroll, true),\n            on(targetWindow, 'resize', dismissOnResize, true),\n            on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true),\n            on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true),\n            on(targetWindow, 'blur', dismissOnTargetWindowBlur, true),\n          ];\n\n          resolve(() => {\n            disposables.forEach(dispose => dispose());\n          });\n        }\n      }, 0);\n    });\n\n    return () => {\n      disposablesPromise.then(dispose => dispose());\n    };\n  }, [\n    hidden,\n    async,\n    hostElement,\n    targetRef,\n    targetWindow,\n    onDismiss,\n    shouldDismissOnWindowFocus,\n    dismissOnTargetClick,\n    preventDismissOnLostFocus,\n    preventDismissOnResize,\n    preventDismissOnScroll,\n    positionsExists,\n    preventDismissOnEvent,\n  ]);\n\n  return mouseDownHandlers;\n}\n\nexport const CalloutContentBase: React.FunctionComponent<ICalloutProps> = React.memo(\n  React.forwardRef<HTMLDivElement, ICalloutProps>((propsWithoutDefaults, forwardedRef) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n    const {\n      styles,\n      style,\n      ariaLabel,\n      ariaDescribedBy,\n      ariaLabelledBy,\n      className,\n      isBeakVisible,\n      children,\n      beakWidth,\n      calloutWidth,\n      calloutMaxWidth,\n      calloutMinWidth,\n      doNotLayer,\n      finalHeight,\n      hideOverflow = !!finalHeight,\n      backgroundColor,\n      calloutMaxHeight,\n      onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = true,\n      target,\n      hidden,\n      onLayerMounted,\n      popupProps,\n    } = props;\n\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const popupRef = React.useRef<HTMLDivElement>(null);\n    const mergedPopupRefs = useMergedRefs(popupRef, popupProps?.ref);\n    const [calloutElement, setCalloutElement] = React.useState<HTMLDivElement | null>(null);\n    const calloutCallback = React.useCallback((calloutEl: any) => {\n      setCalloutElement(calloutEl);\n    }, []);\n    const rootRef = useMergedRefs(hostElement, forwardedRef);\n\n    const [targetRef, targetWindow] = useTarget(props.target, {\n      current: calloutElement,\n    });\n    const getBounds = useBounds(props, targetRef, targetWindow);\n    const positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds, mergedPopupRefs);\n    const maxHeight = useMaxHeight(props, getBounds, targetRef, positions);\n    const [mouseDownOnPopup, mouseUpOnPopup] = useDismissHandlers(\n      props,\n      positions,\n      hostElement,\n      targetRef,\n      targetWindow,\n    );\n\n    // do not set both top and bottom css props from positions\n    // instead, use maxHeight\n    const isForcedInBounds = positions?.elementPosition.top && positions?.elementPosition.bottom;\n    const cssPositions = {\n      ...positions?.elementPosition,\n      maxHeight,\n    };\n    if (isForcedInBounds) {\n      cssPositions.bottom = undefined;\n    }\n\n    useAutoFocus(props, positions, calloutElement);\n\n    React.useEffect(() => {\n      if (!hidden) {\n        onLayerMounted?.();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n    }, [hidden]);\n\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!targetWindow) {\n      return null;\n    }\n\n    const overflowYHidden = hideOverflow;\n\n    const beakVisible = isBeakVisible && !!target;\n    const classNames = getClassNames(styles!, {\n      theme: props.theme!,\n      className,\n      overflowYHidden,\n      calloutWidth,\n      positions,\n      beakWidth,\n      backgroundColor,\n      calloutMaxWidth,\n      calloutMinWidth,\n      doNotLayer,\n    });\n\n    const overflowStyle: React.CSSProperties = {\n      maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%',\n      ...style,\n      ...(overflowYHidden && { overflowY: 'hidden' }),\n    };\n\n    const visibilityStyle: React.CSSProperties | undefined = props.hidden ? { visibility: 'hidden' } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    return (\n      <div ref={rootRef} className={classNames.container} style={visibilityStyle}>\n        <div\n          {...getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES)}\n          className={css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge!])}\n          style={positions ? { ...cssPositions } : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={calloutCallback}\n        >\n          {beakVisible && <div className={classNames.beak} style={getBeakPosition(positions)} />}\n          {beakVisible && <div className={classNames.beakCurtain} />}\n          <Popup\n            // don't use getNativeElementProps for role and roledescription because it will also\n            // pass through data-* props (resulting in them being used in two places)\n            role={props.role}\n            aria-roledescription={props['aria-roledescription']}\n            ariaDescribedBy={ariaDescribedBy}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            className={classNames.calloutMain}\n            onDismiss={props.onDismiss}\n            onMouseDown={mouseDownOnPopup}\n            onMouseUp={mouseUpOnPopup}\n            onRestoreFocus={props.onRestoreFocus}\n            onScroll={onScroll}\n            shouldRestoreFocus={shouldRestoreFocus}\n            style={overflowStyle}\n            {...popupProps}\n            ref={mergedPopupRefs}\n          >\n            {children}\n          </Popup>\n        </div>\n      </div>\n    );\n  }),\n  (previousProps: ICalloutProps, nextProps: ICalloutProps) => {\n    if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n    return shallowCompare(previousProps, nextProps);\n  },\n);\n\n/**\n * (Utility) to find and return the current `Callout` Beak position.\n *\n * @param positions\n */\nfunction getBeakPosition(positions?: ICalloutPositionedInfo): React.CSSProperties {\n  const beakPositionStyle: React.CSSProperties = {\n    ...positions?.beakPosition?.elementPosition,\n    display: positions?.beakPosition?.hideBeak ? 'none' : undefined,\n  };\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n\n/**\n * (Utility) used to compare two different elementPositions to determine whether they are equal.\n *\n * @param prevElementPositions\n * @param newElementPosition\n */\nfunction arePositionsEqual(\n  prevElementPositions: ICalloutPositionedInfo,\n  newElementPosition: ICalloutPositionedInfo,\n): boolean {\n  return (\n    comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) &&\n    comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition)\n  );\n}\n\n/**\n * (Utility) used in **arePositionsEqual** to compare two different elementPositions.\n *\n * @param prevElementPositions\n * @param newElementPositions\n */\nfunction comparePositions(prevElementPositions: IPosition, newElementPositions: IPosition): boolean {\n  for (const key in newElementPositions) {\n    if (newElementPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = prevElementPositions[key];\n      const newPositionEdge = newElementPositions[key];\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nCalloutContentBase.displayName = COMPONENT_NAME;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}